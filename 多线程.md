## 线程池

1.四种线程池
  - newCachedThreadPool:可缓存线程池，工作线程数量无限，当线程空闲超过1分钟则该线程停止
  - newFixedThreadPool:指定线程池的数量，当工作线程数量超出指定容量，则放入池等待队列
  - newSingleThreadPool:只有一个线程的线程池
  - newScheduleThreadPool:容量定长，支持定时和周期性任务的执行，通过将任务添加到DeloyedWorkQueue队列中实现，该队列的头节点就是延迟期满的任务，用的时候出队即可
  
2.线程池的构造参数
  - corePoolsize：核心大小
  - maximumPoolsize：最大容量
  - keepAlive：空闲线程最大生存时间
  - unit：时间单位
  - wordQueue：线程等待队列，一般由ArrayBlockingQueue,LinkedBlockingQueue和sycnhronousQueue实现
  - threadFactory：线程工厂，用于创建线程
  - handle：任务拒绝策略
    - 不执行该任务并返回错误
    - 不执行该任务并不返回任何信息
    - 尝试在线程池之外创建线程处理该任务
    - 丢弃等待队列最前面的任务，然后重新尝试执行任务
  
  注意，线程池在初始化时不论指定的容量和核心大小是多少，不会自动创建线程，即线程池实际大小为0,需要add一次创建一个，除非调用prestartAllCoreThreads()或者prestartCoreThread()方法提前创建
  
3.线程池的状态

  定义:
  
  ```java
  volatile int runState;
  ```
  
  - Running = 0:线程池未初始化
  - ShutDown = 1：让线程池处于关闭状态，即空闲线程全部销毁，在执行任务的线程执行完成之后销毁，最后关闭线程池(shutdown方法)
  - Stop = 2：让线程池处于立刻关闭状态，不论当前线程是否执行都强行销毁并关闭线程池(shutdownnow方法)
  - Terminated：线程全部销毁，等待队列清空，则当前线程池处于该状态
  
4.线程池的运行过程

线程池执行一个任务调用execute()方法或submit()方法，submit方法内部最终还是会调用execute方法，这两个方法的区别在于，execute只接收Runnable实现类，而submit还可以支持Callable实现类，进一步的说，execute方法没有返回值，但是submit有，返回结果为执行结果

  - 判断当前线程池中的线程数量是否超过核心大小，如果没有则new一个线程去处理任务，否则将该任务放入等待队列(源码中这里在execute方法里会判断一次，如果不超过核心大小会再加锁判断一次，因为有可能在这个过程中其他线程向线程池提交了任务)
  - 检查线程中是否有空闲时间超过keep_alive的，如果有则让它去等待队列里取任务执行，如果等待队列为空则销毁该线程，直到线程数量不大于核心大小为止(如果有线程依然空闲但是线程数量不超过核心大小的话就不管了，不用销毁)
  - 如果等待队列也满了，则尝试创建新线程去执行
  - 如果尝试失败(线程数量到达最大容量了)，则执行任务拒绝策略
  
5.addThread(Runnable firstTask)

  - 为提交的任务创建一个对应的Worker对象，调用线程工厂创建新的线程t
  - 将线程的引用赋给Worker的成员变量thread
  - 通过Worker的add(t)方法将对象加入到工作集中
  - 这里的Worker可以理解成一个线程的容器，是一个Runnable的实现类，所以可以像线程一样执行run方法，通过while循环不断执行getTask方法获取新任务(从等待队列中取)
  
6.等待队列
  - ArrayBlockingQueue：数组队列，创建时需要指定大小
  - LinkedBlockingQueue：链表队列
  - synchronousQueue：可以理解为陷阱队列，队列里只有一个元素，如果线程获取该队列的元素但队列为空，则该线程会被阻塞后放入队列，直到另一个线程获取它才会被释放
  
7.线程池的合理配置
  - cpu密集型：线程池大小=cpu数量+1
  - io密集型：线程池大小=cpu数量×2

