## 面向对象三大特性

1.封装：把对象的属性和行为以某种关系整合到一个及合理，通常使用类来实现

2.多态：允许以同一个编程风格来编写程序，以处理种类繁多的已经存在的类
  - 重写 overrideing：运行期动态分配，要求子类方法覆盖父类的方法时参数和返回值都相同，抛出的异常不能超过父类，访问级别不能低于父类的级别
  - 重载 overloading：编译期静态分配，一个类中的两个或以上方法拥有相同的方法名，但是其他的都不相同，典型的例子就是构造函数

3.继承：类似与父子关系，子类能够使用父类的大多数方法和属性(private和final除外)

## 常量和静态变量

1.常量：final修饰，编译期初始化，运行时不能改变其引用或数值，如果方法被声明为final，则不能被子类重写，private默认为final修饰

2.静态变量：static修饰，属于类变量(所有实例共享，和实例的生命周期无关，可以直接通过类名访问，内存中只有一份)，如果是方法被修饰则在类加载阶段就存在，不能是抽象方法，并且因此只能访问该类的静态成员

3.静态语句块：类初始化时直接运行一次

4.静态内部类：常用于实现高效同步的工厂设计模式，不依赖于外部类的实例创建

## String

1.存储：jdk8中使用char数组，jdk9之后使用byte数组

2.性质：不可变对象，可以用于缓存hash，线程安全

3.创建：直接初始化会从String pool中取，如果没有的话则会创建一个Stirng对象，并将其缓存入String pool中，String pool使用堆中内存，本质上一个new String可能会创建两份副本

## 基本数据类型

  | 类型 | 大小 | 取值范围 | 包装器 |
  | :----: | :----:  | :----: | :----: |
  | byte | 8bit | [-128,+127] | Byte |
  | short | 16bit | [-2^15,+2^15-1] | Short |
  | int | 32bit | [-2^31,+2^31-1] | Integer |
  | long | 64bit | [-2^63,+2^63-1] | Long |
  | float | 32bit | [IEEE754,IEEE754] | Float |
  | double | 64bit | 同上 | Double |
  | char | 16bit |[Unicode 0,Unicode 2^16-1] | Character |
  | void | --- | --- | --- |
  
## 缓存池

  | 类型 | 缓存范围 |
  | :-----: | :-----: |
  | boolean | | 所有boolean值 |
  | byte | 所有byte值 |
  | short | -128,127 |
  | int | -128,127 |
  | char | \u0000,\u007F | 
  
  - Integer.valueOf(x) 和 new Integer(x) 一个会使用缓存池中的对象(多次调用指向的是同一个对象) 另一个会新建一个对象
  - valueOf(x) 实现的方法就是判断值是否在缓存池中，如果不在就返回，不在就new一个，然后返回

## 拷贝

1.深拷贝和浅拷贝在基本数据类型下对值拷贝

2.引用类型下深拷贝对对象拷贝副本，浅拷贝对引用进行拷贝

3.java中Object类针对拷贝使用自带的clone方法，要重写clone()方法需要类实现Cloneable接口，该接口是标注接口，如果没有实现Cloneable接口就重写clone方法会抛出异常，不想实现Cloneable方法实现拷贝可以使用拷贝构造函数或拷贝工厂

## 接口和抽象类

1.抽象类可以有类成员和方法体，接口不可以(只能通过反射实例化接口然后添加成员和方法体)，只能有抽象方法

2.抽象类不允许多重继承，接口可以

3.标识接口：用于对类做标记，如果某类需要实现某功能，则必须先实现某接口，比如RandomAccess(随机访问能力)，Cloneable(拷贝)，Seriallizable(序列化)

## 异常

1.运行时异常(RuntimeException)：由jvm管理，编译期不检查，可以捕获和一抛出，比如空指针异常

2.编译时异常：编译期会检查，必须进行处理，否则不能通过编译，RuntimeException以外的异常都是编译时异常，比如IOException,sqlException

3.错误(Error):一种严重的错误，和异常的最大区别在于程序无法处理，比如OOM

## 数组

1.数组的类没有class文件(因为是由jvm运行时动态创建的)，操作由jvm指令直接执行，比如newarray：创建一个数组

2.数组的类名以 [ 开头，和普通的类不一样，并且一维数组和二维数组的类并不一样( [I 和 [[I)，在jvm看来一维数组和二维数组不是同一个类

## equals和hashcode

1.Object对象的hashcode方法是本地方法，c/c++实现，判断地址，需要根据具体需求重写

2.equals通过对象的hashcode方法判断是否相等，所以重写equals方法必须重写hashcode方法
  - 自反性
  - 一致性
  - 对称性
  - 传递性
  - 非null对象调用该方法传入null返回必为false
