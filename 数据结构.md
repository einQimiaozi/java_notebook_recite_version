## 二叉搜索树

- 1.任何节点的左树子节点值均小于该节点
- 2.任何节点的右树子节点值均大于该节点

## 红黑树

- 1.节点非红即黑
- 2.根节点黑色，叶子节点(null的节点)为黑色
- 3.红色节点不能连续
- 4.任何节点出发到其叶子节点经过的黑色节点数量相同
- 5.一个节点的一颗子树深度若为n，则另一颗深度最多为2n
- 6.查询复杂度为O(logn)

## AVL树

- 1.左右子树深度差不超过1，使用平衡因子表示(-1,0,1)
- 2.avl树的左旋和右旋与红黑树相同
- 3.对平衡要求高于红黑树，所以插入删除时会频繁触发节点的旋转调整，效率不如红黑树，但查询效率略高与红黑树
- 4.查询复杂度O(logn)
- 5.avl树具有全部二叉搜索树的性质

## 满二叉树和完全二叉树

- 1.满二叉树：层高为n的满二叉树节点为2^n-1个
- 2.完全二叉树：
  - 该树的深度若为n，则n-1层必须是完全二叉树，第n层全部节点靠左侧
  - 总结点数量-(2^n-1)-1=最后一层的节点数
  - 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树
  - 第m层的节点数量最多为2^(m-1),注意这个和满二叉树的区别

## 快速排序

```java
// 随便找一个x，从右向左找到一个比x小的数high填入x的位置，从左向右找到一个比x大的数low填入high的位置，再把x放回low的位置
// 这个位置就算处理好了，左右递归分治
// 时间复杂度O(nlogn)，复杂度不稳定，正序时速度最慢
public void sort(int[] nums,int l,int r) {
  if(l<r) {
    int x = nums[l];
    int low=l,high=r;
    while(low<high) {
      while(low<high&&nums[high]>=x) --high;
      if(low<high) nums[low++] = nums[high];
      while(low<high&&nums[low]<=x) ++low;
      if(low<high) nums[high--] = nums[low];
      nums[low] = x;
      sort(nums,l,low-1);
      sort(nums,low+1,r);
    }
  }
}
```

## 冒泡排序

```java
// 比较两个相邻元素，倒序则交换，这样每一次可以使最大的元素飘到数组的尾部，执行n-1次后就可以使得长度为n的数组正序
public void sort(int[] nums) {
  for(int i=1;i<nums.length;i++) {
    for(int j=0;j<nums.length-1;j++) {
      if(nums[j]>nums[j+1]) {
        int temp = nums[j];
        nums[j] = nums[j+1];
        nums[j+1] = temp;
      }
    }  
  }
}
```

## 堆排序

```java
// 从堆中最后一个非叶子节点开始建堆(n/2-1)，逆序遍历完成建堆,建堆的原则就是保证节点的左右子树符合最大堆或最小堆的原则，如果不符合需要调整的话调整之后再检查一下被调整过的子节点的子节点是否依然满足该原则
// 建堆完成之后使用一个逆序指针和头节点不断互换，每次互换之后调整头节点和其左右子树即可

public void HeapSort(int[] nums) {
  buildHeap(nums);  // 建堆
  // 调整根节点
  for(int i=nums.length-1;i>0;i--) {
    swap(nums,0,i);
    helper(nums,0,i);  // 调整一个节点则len就减少一个
  }
}

// 建堆
public void buildHeap(int[] nums) {
  int n = nums.length;
  for(int i=n/2-1;i>=0;i--) {
    helper(nums,i,n);
  }
}

// 调整
public void helper(int[] nums,int i,int len) {
  int larger = i;
  int left = 2*i+1;
  int right = 2*i+2;
  if(left<len&&nums[left]>nums[larger]) larger = left;
  if(right<len&&nums[right]>nums[larger]) larger = right;
  // 如果不满足最大堆原则则交换并检查交换后的子树是否还符合最大堆原则
  if(larger!=i) {
    swap(nums,i,larger);
    helper(nums,larger,len);
  }
}

public void swap(int[] nums,int i,int j) {
  int temp = nums[i];
  nums[i] = nums[j];
  nums[j] = temp;
}
```
