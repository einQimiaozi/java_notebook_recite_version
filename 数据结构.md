## 二叉搜索树

- 1.任何节点的左树子节点值均小于该节点
- 2.任何节点的右树子节点值均大于该节点

## 红黑树

- 1.节点非红即黑
- 2.根节点黑色，叶子节点(null的节点)为黑色
- 3.红色节点不能连续
- 4.任何节点出发到其叶子节点经过的黑色节点数量相同
- 5.一个节点的一颗子树深度若为n，则另一颗深度最多为2n
- 6.查询复杂度为O(logn)

## AVL树

- 1.左右子树深度差不超过1，使用平衡因子表示(-1,0,1)
- 2.avl树的左旋和右旋与红黑树相同
- 3.对平衡要求高于红黑树，所以插入删除时会频繁触发节点的旋转调整，效率不如红黑树，但查询效率略高与红黑树
- 4.查询复杂度O(logn)
- 5.avl树具有全部二叉搜索树的性质

## 满二叉树和完全二叉树

- 1.满二叉树：层高为n的满二叉树节点为2^n-1个
- 2.完全二叉树：
  - 该树的深度若为n，则n-1层必须是完全二叉树，第n层全部节点靠左侧
  - 总结点数量-(2^n-1)-1=最后一层的节点数
  - 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树
  - 第m层的节点数量最多为2^(m-1),注意这个和满二叉树的区别

## 快速排序

```java
public void sort(int[] nums,int l,int r) {
  if(l<r) {
    int x = nums[l];
    int low=l,high=r;
    while(low<high) {
      while(low<high&&nums[high]>=x) --high;
      if(low<high) nums[low++] = nums[high];
      while(low<high&&nums[low]<=x) ++low;
      if(low<high) nums[high--] = nums[low];
      nums[low] = x;
      sort(nums,l,low-1);
      sort(nums,low+1,r);
    }
  }
}
```
