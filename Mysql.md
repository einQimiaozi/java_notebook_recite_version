## Mysql结构

![arch](https://pcsdata.baidu.com/thumbnail/6796fc7d5n371367992f74e65f993215?fid=1508469986-16051585-992196802664089&rt=pr&sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-7wfPhbZpcjstvvPLAR6HHy2xeSc%3D&expires=2h&chkv=0&chkbd=0&chkpc=&dp-logid=2650161199&dp-callid=0&time=1618023600&size=c1600_u1600&quality=100&vuk=-&ft=video)

查询缓存在mysql8.0之后被取消，一般认为数据库若不处于静态图状态则查询缓存命中率极低，不建议使用

## 基本数据类型

1.整型
  - 1.tinyint smalliont,meduimint,int
  - 2.bigint(用于记录大数)

2.浮点型
  - 1.float(8字节) double(16字节)
  - 2.decimal(大数，用于存储货币单位)

3.日期
  - 1.date，time，year
  - 2.timestamp(4字节，1970-2038年) datetime(8字节，一般比timestamp好用)

4.varchar
  - 用于存储可变长字符串，比定长更节省空间
  - 使用varchar(n)指定长度
  - 使用1到2个额外的字节记录字符串长度
  - 由于程度可变，需要update时做额外工作，会影响update效率
  - 适用场景：
  - 字符串列长度大于平均长度
  - 列的更新很少
  - 使用了像utf-8这样复杂的字符集

5.char

  - 定长
  - 适合存储短字符串

## Mysql的执行过程

1.客户端发送查询语句给服务器

2.服务器见检查缓存，根据命中情况决定返回数据or对sql进行解析

4.从优化器生成对应的执行计划

5.根据执行计划调用存储引擎的api查询

6.将结果返回给客户端

## Mysql三大范式

1.数据的每一行不可拆分

2.主键必须能够唯一的区分数据，即非主键依赖主键

3.非主键属性不能依赖与其他非主键属性，比如部门和经理两个属性，如果部门经理唯一的话，那么由部门就可以推出其经理，相当与存经理这个key本身是浪费了资源

## 事务的ACID

1.a-->原子性：一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做，通过undo log来保障

2.c-->持久性：事务一旦提交，它对数据库的改变就应该是永久性的，通过redo log来保障

3.i-->隔离性:事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰,通过锁和事物的隔离级别来保障

4.d-->一致性：事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态，原子性、持久性和隔离性，都是为了保证数据库状态的一致性

## 事务隔离级别

- 读未提交：事务提交前其他事务就可以看到，读不加锁，写加共享锁，会导致脏读幻读
- 读提交：事务提交后其他事务才能看到，读加共享锁，写加排他锁，会导致幻读，不可重复读
- 可重复读：一个事务执行开启阶段会创建一个当前数据状态的静态视图，执行过程中所有的数据都以这个静态视图为准，读加共享锁，写加间隙排他锁(一种行锁)，会导致幻读，innodb的默认隔离级别
- 串行化：读加共享锁，写加排他锁，锁全部使用表锁

## 脏读 幻读 不可重复读

脏读：事务提交前其他线程读取了未提交的数据

幻读：事务a对数据库进行修改后事务b插入了新数据，事务a提交前看到了未被修改的新数据会以为是自己遗漏了修改

不可重复读：同一事务对同一数据在事务内的两次查询结果不同，通常是因为另一个线程在这期间对数据修改并提交导致的

## 索引

mysql索引采用b+tree结构，叶节点记录数据

![索引结构](https://pcsdata.baidu.com/thumbnail/c30a6e71fp49af625326ad611dfd6f8f?fid=1508469986-16051585-282346189855871&rt=pr&sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-masFNqg37SqgWK5mTrsyDx2ovP0%3D&expires=2h&chkv=0&chkbd=0&chkpc=&dp-logid=2888778553&dp-callid=0&time=1618027200&size=c1600_u1600&quality=100&vuk=-&ft=video)

b+树结构 层高:2-4  子节点数量：每个父节点下带该1200个 查询次数：最多三次  叶子节点这一层本身也是个链表 基本单位为page，page及其下级单位物理和逻辑空间都连续

主键索引：主键索引的叶子节点里存的是一个区

非主键索引：非主键索引的叶子节点里存的是主键索引，根据主键索引查找数据，也称为二级索引，会引发回表(非主键->主键的二次查询)，mysql使用覆盖索引机制尽可能避免回表以提高性能

最左前缀原则：叶子节点按照左->右的顺序存放，方便查询

索引下推：对于数据的非主键不做回表，而是直接使用逻辑判断，不满足条件则跳过，举例 (a,20) 直接查询主键a的数据是否为20,不满足则跳过 (mysql5.6之前是先找主键为a的数据，然后再这堆数据里找id为20的数据)

为什么使用b+树作为索引结构(b+树索引性能分析)：索引本身很大，不能全部存在内存里，所以每次实际上会去磁盘找，但磁盘的io性能和内存差距较大，所以每次实际上会把查找结果的数据和其左右两边的部分数据一起载入内存(所谓的磁盘预读，根据局部性原理，程序运行时，被用得到的数据附近的其他数据往往也会马上被用到)，减少磁盘io，mysql中使用b树可以让一个节点的阶数根据页的大小调整，使得一个页能够一次性读取更多数据，减少磁盘io，同时b+树的非叶子节点不存数据，所以相当与节点更多，层高更小，查询的速度会比b树更快，并而b+树的叶子节点中的关键字链式相接，查找失败后不需要中序回溯，只需要像链表一样顺序查找就可以，所以适合该需求

索引优化建议：
  - 1.使用自增主键维护叶节点有序性比每次排序效率更高
  - 2.对于普通索引，内部存储的是主键，所以主键越短，内存消耗越低

## MVCC(多版本并发控制)

![data](https://pcsdata.baidu.com/thumbnail/178077666o2f82b714509d6908289872?fid=1508469986-16051585-270984009239186&rt=pr&sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-5qLgy4RCfuDknwcmcCOT39Ud2Ro%3D&expires=2h&chkv=0&chkbd=0&chkpc=&dp-logid=3210581287&dp-callid=0&time=1618030800&size=c1600_u1600&quality=100&vuk=-&ft=video)

innode数据行结构

DATA_TRX_ID:记录插入或更新的最后一个事务的id

DATA_ROLL_PTR：指向该行对应的回滚段的指针，该行所有的旧版本都在undolog上以链表形式保存，实际上该指针指向的就是这玩意

1.redolog:记录每次提交的操作，结构是一个数据，通过头指针和尾指针维护写入位置，数组满了就刷盘然后清空刷盘成功的数据，指针后移，用于实现crash-safe(前滚操作)，保证持久化，innodb中才存在的日志

2.undo：log：存放数据库修改前的数据，用于回滚操作，innode中才存在的日志，用于保证事务原子性和MVCC实现

mvcc：读不加锁，读写不冲突，适合读多写少的场景，读有两种模式(快照读->返回记录的当前版本，不加锁 当前读->返回记录的最新版本，加锁，保证其他线程不修改)，需要额外空间维护记录

mvcc的实现原理：
  - 写：事务以排他锁的形式修改数据，把修改的数据放入undolog中，通过DATA_ROLL_PTR关联数据，如果事务提交不成功则回复undolog中的数据(回滚，保证原子性)
  - 读：根据读模式决定是读数据库当前版本还是读undolog

undo log工作流程：
  - 1.开始事务
  - 2.记录数据行快照到undolog
  - 3.更新数据
  - 4.将undolog刷盘(这里有个优化，将多次io放入缓存中，之后随机将几次io捆绑成一次io刷盘)
  - 5.提交事务

## 锁

1.全局锁(FTWRL)：使整个数据库处于只读状态，常用与全库备份和不支持隔离级别的引擎做隔离，缺点是会造成数据库阻塞，引起主从延迟

2.表锁：对表加锁，开销小速度快并发度低，不会死锁，锁冲突概率高

3.行锁：对行加锁，一切和表锁相反......

4.排他锁和共享锁：懒得解释了

6.间隙锁：在索引之间加锁，比如索引a，b，c，如果锁b，那么实际上锁是加在a b之间和b c之间的

7.意向锁：多粒度加锁，允许行锁和表锁同时存在，插入意向锁是一种表锁，本质上是一种处理表锁和行锁冲突的方法，举例 事务a锁了一行，事务b申请该行所在的表的表锁，这样表锁和行锁就发生了冲突，事务a在锁行之前需要申请意向锁加锁，事务b在申请表锁时如果发现意向锁被a持有了一个行锁，则阻塞自己对表锁的申请

## Mysql常用查询优化

1.避免在where中使用!= < >，因为引擎会放弃索引而使用全表扫描

2.少用is null和=0

3.少用or，会放弃索引，可用union将查询命令分为两个单独执行

4.where中不要对字段进行操作

5.控制索引的量，太大会影响插入和更新的效率，因为插入更系都会重建索引

6.尽量保证索引不失效

