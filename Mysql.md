## Mysql结构

![arch](https://pcsdata.baidu.com/thumbnail/6796fc7d5n371367992f74e65f993215?fid=1508469986-16051585-992196802664089&rt=pr&sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-7wfPhbZpcjstvvPLAR6HHy2xeSc%3D&expires=2h&chkv=0&chkbd=0&chkpc=&dp-logid=2650161199&dp-callid=0&time=1618023600&size=c1600_u1600&quality=100&vuk=-&ft=video)

查询缓存在mysql8.0之后被取消，一般认为数据库若不处于静态图状态则查询缓存命中率极低，不建议使用

## Mysql三大范式

1.数据的每一行不可拆分

2.主键必须能够唯一的区分数据，即非主键依赖主键

3.非主键属性不能依赖与其他非主键属性，比如部门和经理两个属性，如果部门经理唯一的话，那么由部门就可以推出其经理，相当与存经理这个key本身是浪费了资源

## 事务的ACID

1.a-->原子性：一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做，通过undo log来保障

2.c-->持久性：事务一旦提交，它对数据库的改变就应该是永久性的，通过redo log来保障

3.i-->隔离性:事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰,通过锁和事物的隔离级别来保障

4.d-->一致性：事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态，原子性、持久性和隔离性，都是为了保证数据库状态的一致性

## 事务隔离级别

- 读未提交：事务提交前其他事务就可以看到，读不加锁，写加共享锁，会导致脏读幻读
- 读提交：事务提交后其他事务才能看到，读加共享锁，写加排他锁，会导致幻读，不可重复读
- 可重复读：一个事务执行开启阶段会创建一个当前数据状态的静态视图，执行过程中所有的数据都以这个静态视图为准，读加共享锁，写加间隙排他锁(一种行锁)，会导致幻读，innodb的默认隔离级别
- 串行化：读加共享锁，写加排他锁，锁全部使用表锁

## 脏读 幻读 不可重复读

脏读：事务提交前其他线程读取了未提交的数据

幻读：事务a对数据库进行修改后事务b插入了新数据，事务a提交前看到了未被修改的新数据会以为是自己遗漏了修改

不可重复读：同一事务对同一数据在事务内的两次查询结果不同，通常是因为另一个线程在这期间对数据修改并提交导致的

## 索引

mysql索引采用b+tree结构，叶节点记录数据

![索引结构](https://pcsdata.baidu.com/thumbnail/c30a6e71fp49af625326ad611dfd6f8f?fid=1508469986-16051585-282346189855871&rt=pr&sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-masFNqg37SqgWK5mTrsyDx2ovP0%3D&expires=2h&chkv=0&chkbd=0&chkpc=&dp-logid=2888778553&dp-callid=0&time=1618027200&size=c1600_u1600&quality=100&vuk=-&ft=video)

层高:2-4  子节点数量：每个父节点下带该1200个 查询次数：最多三次  叶子节点这一层本身也是个链表 基本单位为page，page及其下级单位物理和逻辑空间都连续

主键索引：主键索引的叶子节点里存的是一个区

非主键索引：非主键索引的叶子节点里存的是主键索引，根据主键索引查找数据，也称为二级索引，会引发回表(非主键->主键的二次查询)，mysql使用覆盖索引机制尽可能避免回表以提高性能

最左前缀原则：叶子节点按照左->右的顺序存放，方便查询

索引下推：对于数据的非主键不做回表，而是直接使用逻辑判断，不满足条件则跳过，举例 (a,20) 直接查询主键a的数据是否为20,不满足则跳过 (mysql5.6之前是先找主键为a的数据，然后再这堆数据里找id为20的数据)

索引优化建议：
  - 1.使用自增主键维护叶节点有序性比每次排序效率更高
  - 2.对于普通索引，内部存储的是主键，所以主键越短，内存消耗越低

