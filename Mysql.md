## Mysql结构

![arch](https://pcsdata.baidu.com/thumbnail/6796fc7d5n371367992f74e65f993215?fid=1508469986-16051585-992196802664089&rt=pr&sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-7wfPhbZpcjstvvPLAR6HHy2xeSc%3D&expires=2h&chkv=0&chkbd=0&chkpc=&dp-logid=2650161199&dp-callid=0&time=1618023600&size=c1600_u1600&quality=100&vuk=-&ft=video)

查询缓存在mysql8.0之后被取消，一般认为数据库若不处于静态图状态则查询缓存命中率极低，不建议使用

## 基本数据类型

1.整型
  - 1.tinyint smalliont,meduimint,int
  - 2.bigint(用于记录大数)

2.浮点型
  - 1.float(8字节) double(16字节)
  - 2.decimal(大数，用于存储货币单位)

3.日期
  - 1.date，time，year
  - 2.timestamp(4字节，1970-2038年) datetime(8字节，一般比timestamp好用)

4.varchar
  - 用于存储可变长字符串，比定长更节省空间
  - 使用varchar(n)指定长度
  - 使用1到2个额外的字节记录字符串长度
  - 由于程度可变，需要update时做额外工作，会影响update效率
  - 适用场景：
  - 字符串列长度大于平均长度
  - 列的更新很少
  - 使用了像utf-8这样复杂的字符集

5.char

  - 定长
  - 适合存储短字符串

## Mysql三大范式

1.数据的每一行不可拆分

2.主键必须能够唯一的区分数据，即非主键依赖主键

3.非主键属性不能依赖与其他非主键属性，比如部门和经理两个属性，如果部门经理唯一的话，那么由部门就可以推出其经理，相当与存经理这个key本身是浪费了资源

## 事务的ACID

1.a-->原子性：一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做，通过undo log来保障

2.c-->持久性：事务一旦提交，它对数据库的改变就应该是永久性的，通过redo log来保障

3.i-->隔离性:事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰,通过锁和事物的隔离级别来保障

4.d-->一致性：事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态，原子性、持久性和隔离性，都是为了保证数据库状态的一致性

## 事务隔离级别

- 读未提交：事务提交前其他事务就可以看到，读不加锁，写加共享锁，会导致脏读幻读
- 读提交：事务提交后其他事务才能看到，读加共享锁，写加排他锁，会导致幻读，不可重复读
- 可重复读：一个事务执行开启阶段会创建一个当前数据状态的静态视图，执行过程中所有的数据都以这个静态视图为准，读加共享锁，写加间隙排他锁(一种行锁)，会导致幻读，innodb的默认隔离级别
- 串行化：读加共享锁，写加排他锁，锁全部使用表锁

## 脏读 幻读 不可重复读

脏读：事务提交前其他线程读取了未提交的数据

幻读：事务a对数据库进行修改后事务b插入了新数据，事务a提交前看到了未被修改的新数据会以为是自己遗漏了修改

不可重复读：同一事务对同一数据在事务内的两次查询结果不同，通常是因为另一个线程在这期间对数据修改并提交导致的

## 索引

mysql索引采用b+tree结构，叶节点记录数据

![索引结构](https://pcsdata.baidu.com/thumbnail/c30a6e71fp49af625326ad611dfd6f8f?fid=1508469986-16051585-282346189855871&rt=pr&sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-masFNqg37SqgWK5mTrsyDx2ovP0%3D&expires=2h&chkv=0&chkbd=0&chkpc=&dp-logid=2888778553&dp-callid=0&time=1618027200&size=c1600_u1600&quality=100&vuk=-&ft=video)

层高:2-4  子节点数量：每个父节点下带该1200个 查询次数：最多三次  叶子节点这一层本身也是个链表 基本单位为page，page及其下级单位物理和逻辑空间都连续

主键索引：主键索引的叶子节点里存的是一个区

非主键索引：非主键索引的叶子节点里存的是主键索引，根据主键索引查找数据，也称为二级索引，会引发回表(非主键->主键的二次查询)，mysql使用覆盖索引机制尽可能避免回表以提高性能

最左前缀原则：叶子节点按照左->右的顺序存放，方便查询

索引下推：对于数据的非主键不做回表，而是直接使用逻辑判断，不满足条件则跳过，举例 (a,20) 直接查询主键a的数据是否为20,不满足则跳过 (mysql5.6之前是先找主键为a的数据，然后再这堆数据里找id为20的数据)

索引优化建议：
  - 1.使用自增主键维护叶节点有序性比每次排序效率更高
  - 2.对于普通索引，内部存储的是主键，所以主键越短，内存消耗越低

## MVCC(多版本并发控制)

![data](https://pcsdata.baidu.com/thumbnail/178077666o2f82b714509d6908289872?fid=1508469986-16051585-270984009239186&rt=pr&sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-5qLgy4RCfuDknwcmcCOT39Ud2Ro%3D&expires=2h&chkv=0&chkbd=0&chkpc=&dp-logid=3210581287&dp-callid=0&time=1618030800&size=c1600_u1600&quality=100&vuk=-&ft=video)

innode数据行结构

DATA_TRX_ID:记录插入或更新的最后一个事务的id

DATA_ROLL_PTR：指向该行对应的回滚段的指针，该行所有的旧版本都在undolog上以链表形式保存，实际上该指针指向的就是这玩意

1.redolog:记录每次提交的操作，结构是一个数据，通过头指针和尾指针维护写入位置，数组满了就刷盘然后清空刷盘成功的数据，指针后移，用于实现crash-safe(前滚操作)，保证持久化，innodb中才存在的日志

2.undo：log：存放数据库修改前的数据，用于回滚操作，innode中才存在的日志，用于保证事务原子性和MVCC实现

mvcc：读不加锁，读写不冲突，适合读多写少的场景，读有两种模式(快照读->返回记录的当前版本，不加锁 当前读->返回记录的最新版本，加锁，保证其他线程不修改)，需要额外空间维护记录

mvcc的实现原理：
  - 写：事务以排他锁的形式修改数据，把修改的数据放入undolog中，通过DATA_ROLL_PTR关联数据，如果事务提交不成功则回复undolog中的数据(回滚，保证原子性)
  - 读：根据读模式决定是读数据库当前版本还是读undolog

undo log工作流程：
  - 1.开始事务
  - 2.记录数据行快照到undolog
  - 3.更新数据
  - 4.将undolog刷盘(这里有个优化，将多次io放入缓存中，之后随机将几次io捆绑成一次io刷盘)
  - 5.提交事务

## 锁

1.全局锁(FTWRL)：使整个数据库处于只读状态，常用与全库备份和不支持隔离级别的引擎做隔离，缺点是会造成数据库阻塞，引起主从延迟

2.表锁：对表加锁，开销小速度快并发度低，不会死锁，锁冲突概率高

3.行锁：对行加锁，一切和表锁相反......

4.排他锁和共享锁：懒得解释了

6.间隙锁：在索引之间加锁，比如索引a，b，c，如果锁b，那么实际上锁是加在a b之间和b c之间的

7.意向锁：多粒度加锁，允许行锁和表锁同时存在，插入意向锁是一种表锁，本质上是一种处理表锁和行锁冲突的方法，举例 事务a锁了一行，事务b申请该行所在的表的表锁，这样表锁和行锁就发生了冲突，事务a在锁行之前需要申请意向锁加锁，事务b在申请表锁时如果发现意向锁被a持有了一个行锁，则阻塞自己对表锁的申请

## Mysql常用查询

1.避免在where中使用!= < >，因为引擎会放弃索引而使用全表扫描

2.少用is null和=0

3.少用or，会放弃索引，可用union将查询命令分为两个单独执行

4.where中不要对字段进行操作

5.控制索引的量，太大会影响插入和更新的效率，因为插入更系都会重建索引

6.尽量保证索引不失效

