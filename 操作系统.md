## 进程和线程

1.进程：资源分配的基本单位，由进程控制块(PCB)控制，通信较为麻烦，开销大

2.线程：独立调度的基本单位，由进程创建，一个进程下的多个线程共享进程资源，开销小，自己不用有资源，可以通过读写同一进程中的资源通信

## 进程间通信方式(ipc)

进程间通信方式在非单机环境下需要使用socket，所以现在的os都继承了基于socket的进程间通信机制

1.pipe(管道)：半双工，只能父子进程之间通信

2.namepipe(命名管道，也叫FIFO)：半双工，允许了兄弟进程之间通信

3.信号量：计数器，本质上是个锁机制，用于维护进程之间或进程的线程之间的同步状态

4.消息队列：其实就是个内核消息链表，用它可以使得消息不再只能是无格式字节流，并且链表长度不受限制，独立于进程存在

5.共享内存：一进程创建，多进程使用，速度快效率高，配合信号量控制同步，完美

6.socket：实现不同设备之间的通信

## 进程状态切换

![state](https://pcsdata.baidu.com/thumbnail/6038408ebv17d8b65ef657ccdd3acc02?fid=1508469986-16051585-672340975708142&rt=pr&sign=FDTAER-yUdy3dSFZ0SVxtzShv1zcMqd-5rYyRUfPi1cyqrG2Eo%2BW7ursEYs%3D&expires=2h&chkv=0&chkbd=0&chkpc=&dp-logid=4001750752&dp-callid=0&time=1619629200&size=c1600_u1600&quality=100&vuk=-&ft=video)

这个和多线程里的线程状态切换很像，看图就可以，不细说了

## 页面置换算法

1.LRU：使用队列，每当页面被访问到就将其取出并放置到队尾，当队列满后或需要删除页面时，执行出队，所以该算法会将长时间没有被访问的页面中存在最久的页面换掉

2.OPT：选择之后不再会访问的页面进行淘汰，如果没有，则淘汰距离再次访问最远的页面

3.FIFO：先进先出

4.clock：该算法对每个页面设置访问位u，使用一个指针像时钟的指针一样循环推进
  - u=0时，将数据放入该页面
  - u=1时，跳过该页面并将u置为0
  - 该算法其实就是通过重置访问位来区分页面的新旧程度，旧页面or空页面就会被淘汰

## 一个程序的创建到运行到运行结束的过程

1.编译：源代码通过预处理和编译器转成汇编文件

2.链接：若程序以来外部lib，则通过静态链接(lib在程序文件中设定好)or动态链接(系统中存在，所有程序通过引用共享该lib)生成最终的可执行文件

3.装载和运行：内核创建一个进程，将进程控制权交给程序的入口，并把代码从硬盘加载到该进程的内存中执行(按需加载)，cpu分配时间片给进程让其独占cpu

4.结束：当cpu分配给进程的时间片用完，进程会被挂起，等待下一个时间片的到来，直到程序运行结束，销毁进程，清理内存

## 死锁的处理

1.鸵鸟法：就不管了，爱死不死

2.死锁检测：银行家算法或图遍历检测整个阻塞回路

3.死锁恢复：
  - 剥夺陷于死锁状态的进程的资源，直到思索解除
  - 提前保存检查点让所有进程不断退回，直到死锁解除
  - 逐个或一次性kill所有陷入死锁的进程

4.死锁预防：
  - 规定加锁顺序
  - 设定最大等待时长，超过该时长则进程必须释放锁
  - 根据应用场景适当的使用共享锁(如同一进程可重入锁，读共享等)
  - 增大锁粒度，规定所有进程请求某个资源时必须请求全部资源，但是不建议使用，锁粒度太大会导致执行效率底下


