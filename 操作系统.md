## 进程和线程

1.进程：资源分配的基本单位，由进程控制块(PCB)控制，通信较为麻烦，开销大

2.线程：独立调度的基本单位，由进程创建，一个进程下的多个线程共享进程资源，开销小，自己不用有资源，可以通过读写同一进程中的资源通信

## 进程间通信方式(ipc)

进程间通信方式在非单机环境下需要使用socket，所以现在的os都继承了基于socket的进程间通信机制

1.pipe(管道)：半双工，只能父子进程之间通信

2.namepipe(命名管道，也叫FIFO)：半双工，允许了兄弟进程之间通信

3.信号量：计数器，本质上是个锁机制，用于维护进程之间或进程的线程之间的同步状态，信号量的计数器为0时当前资源不可获取(被锁住了)，为n时可获取，并且一个进程获取后将其置为n-1

4.消息队列：其实就是个内核消息链表，用它可以使得消息不再只能是无格式字节流，并且链表长度不受限制，独立于进程存在

5.共享内存：一进程创建，多进程使用，速度快效率高，配合信号量控制同步，完美

6.socket：实现不同设备之间的通信

## 进程状态切换

![state](https://s1.ax1x.com/2018/11/27/FE8Sfg.png)

就绪态：一个进程列表，等待运行态调用

运行态：运行进程，一个进程一个时间片，时间片到达后进程被放回就绪态，运行态再去取下一个进程

注意：就绪态不能直接转换为阻塞态，阻塞态只能由运行态触发，阻塞态结束后会将进程先放入就绪的进程列表中，而不是直接转回运行态

## 内核态和用户态

用户态：当前运行进程的cpu只能访问该进程所有的内存，不能访问外围设备，对应ring3

内核态：cpu可以访问全部内存，可以访问外围设备和网卡，可以切换进程，对应ring0(在计算机发展早期，外围设备和驱动属于ring1和ring2，只有全部内存访问权限属于ring0，后期取消了ring1和ring2的概念，所以这些全部属于ring0了)

内核态和用户态切换的三种方式：

1.系统调用：用户进程通过系统调用这个机制主动请求切换内核态来处理和执行当前的数据，处理结束后os会将cpu重置为用户态

2.异常：cpu执行程序时触发了用户态无法处理的系统异常，此时会切换到内核态处理

3.外围设备的中断：外围设备处理任务结束后会通过中断告知进程，此时进程需要响应，如果该进程的cpu恰好处于用户态的话则会切换到内核态来处理

## 页面置换算法

1.LRU：使用队列，每当页面被访问到就将其取出并放置到队尾，当队列满后或需要删除页面时，执行出队，所以该算法会将长时间没有被访问的页面中存在最久的页面换掉

2.OPT：选择之后不再会访问的页面进行淘汰，如果没有，则淘汰距离再次访问最远的页面

3.FIFO：先进先出

4.clock：该算法对每个页面设置访问位u，使用一个指针像时钟的指针一样循环推进
  - u=0时，将数据放入该页面
  - u=1时，跳过该页面并将u置为0
  - 该算法其实就是通过重置访问位来区分页面的新旧程度，旧页面or空页面就会被淘汰

## 虚拟内存

虚拟内存是不连续的物理内存的映射，虚拟内存的基本单位是页，每个进程通过虚拟内存维护自己独有的物理内存映射

虚拟内存可以超过物理内存大小，如果虚拟内存映射到了不存在的页，则可以通过映射硬件(比如磁盘)实现虚拟内存，所以一个进程可以拥有超过该系统物理大小的内存

映射方法：
  - 虚拟地址共16位，前4位映射到页表中的一个index下
  - 页表中的每个index里存储4位，第4位表示该页是否存在于内存中
  - 将虚拟地址的前4位换成页表中index的前3位，生成的新的15位地址就是物理地址

[!dizhi](https://camo.githubusercontent.com/1f3a60c6aaac33dd000b9d6a39069d3ddaf2bb04c22b8bcda782eca707eb64fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63663433383661312d353863392d346563612d613137662d6531326231653937373065622e706e67)

## 一个程序的创建到运行到运行结束的过程

1.编译：源代码通过预处理和编译器转成汇编文件

2.链接：若程序以来外部lib，则通过静态链接(lib在程序文件中设定好)or动态链接(系统中存在，所有程序通过引用共享该lib)生成最终的可执行文件

3.装载和运行：内核创建一个进程，将进程控制权交给程序的入口，并把代码从硬盘加载到该进程的内存中执行(按需加载)，cpu分配时间片给进程让其独占cpu

4.结束：当cpu分配给进程的时间片用完，进程会被挂起，等待下一个时间片的到来，直到程序运行结束，销毁进程，清理内存

## 死锁的处理

1.鸵鸟法：就不管了，爱死不死

2.死锁检测：银行家算法或图遍历检测整个阻塞回路

2.1 银行家算法：

![bank](https://github.com/einQimiaozi/java_notebook_recite_version/blob/main/img/bank.jpg)

3.死锁恢复：
  - 剥夺陷于死锁状态的进程的资源，直到思索解除
  - 提前保存检查点让所有进程不断退回，直到死锁解除
  - 逐个或一次性kill所有陷入死锁的进程

4.死锁预防：
  - 规定加锁顺序
  - 设定最大等待时长，超过该时长则进程必须释放锁
  - 根据应用场景适当的使用共享锁(如同一进程可重入锁，读共享等)
  - 增大锁粒度，规定所有进程请求某个资源时必须请求全部资源，但是不建议使用，锁粒度太大会导致执行效率底下


