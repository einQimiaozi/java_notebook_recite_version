## fail-fast

所有线程不安全的集合都有该机制，用于检查错误

集合对象和迭代该集合的迭代对象各自维护一个modcount，每次修改集合结构的时候执行modcount++，当两个modcount不一致时说明发生了数据同步问题，会抛出ConcurrentModifactionExcaption错误。

## ArrayList

继承自Abstractlist

构造函数为空的Object数组，protected修饰，transient修饰

transient：使得实现了Serilizable接口的对象中的被修饰属性不可序列化，保证数据在传输过程中的安全性

第一次执行add操作时扩容，默认大小为10,容量上限为Integer.MAX_VALUE-8，也可以指定容量

扩容时使用位操作(int new capacity = oldcapacity + oldcapacity>复杂度>1)，扩容大小为1.5倍，扩容后如果小于指定大小就按指定大小扩容，超过最大容量抛出OOM。

底层为数组，占用连续内存。

插入和删除如果不是尾部追加，或者扩容时，使用System.arraycopy方法移动出插入位置，消耗较大，需要频繁插入删除的场景不适合ArrayList，如果能够根据应用场景预先设置好大小可以避免频繁移动数组

缩容操作不会自动触发，需要手动调用，使用syste.arraycopy移动，缩容后大小为当前size。

实现了RandomAccess接口。

支持插入null元素。

复杂度：

  - get O(1)
  - add(E) O(1)
  - add(index,E) O(n)
  - remove() O(n) 

## LinkedList

底层是双向链表结构，元素节点使用protected和transient修饰。

支持插入null元素。

对其他Collection对象的批量插入采用Collection.toArray方法(遍历，转成Object数组返回)，不断尾插，使用整型size记录链表长度。

尾部追加元素使用尾插法，其他情况下使用头插法(调用node方法，该方法会根据index判断当前插入的位置在链表的前半段还是后半段，遍历返回该位置，因为插入后该位置实际上要后移，所以使用头插法)。

支持按元素查询，会先判断元素是否为null，因为null和普通元素的判断相等的方法不同(==和equals)，判断后根据情况遍历返回第一个满足条件的节点。

不需要扩容，插入删除效率高，查找效率低。

复杂度：

  - get O(n)
  - add(E) O(1)
  - add(index,E) O(n/2)
  - remove O(1)

## HashMap

底层构造函数是空的Node数组，也叫哈希桶，protected和transient修饰，还有一个加载因子，默认为0.75，Node对象结构如下(单向链表)

```java
static class Node<k,v> implements Map.Entry<k,v> {
  final int hash; // 哈希值
  final k key;
  v value;
  Node<k,v> next; // 后继节点
}
```

每一个节点的hash值通过key的hash值和value的hash值异或得到

第一次add执行初始化，threshold=容量×加载因子，超过threshold会触发扩容

默认容量为16,每次两倍扩容(位运算 int newcapacity = oldcapacity>>1),容量必须为2的n次方，可以指定容量，底层会调用tablesizefor方法返回一个大于并最接近指定容量的容量(使用或+位运算)

当桶内链表长度大于7时转换结构为红黑树，小于7时降级为链表，等于7时不做任何操作

```java
static final int tablesizefor(int cap) {
   int n = cap-1;
   n |= n>>1;
   n |= n>>2;
   n |= n>>4;
   n |= n>>8;
   n |= n>>16;
   return (n<0)? |= (n>=MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY = n+1; // 边界检查
}
```

hash桶位置计算方法：元素的hash值模以容量(源码中使用位操作 [e.hash & cap-1]),因此容量必须是2的n次方(这样才能用位操作取模)

扩容过程

  - 1.判断是否要初始化
  - 2.边界判断(hashmap的容量上限为2^31-1)
  - 3.计算扩容后容量(位操作)
  - 4.如果未初始化则执行初始化，如果未初始化但是有threshold，则初始化同时设置当前的容量为threshold
  - 5.计算新阈值并new一个新的node数组
  - 6.如果旧hash桶内有元素，则遍历老桶，每次遍历将引用指向null，方便GC
  - 7.由于每次扩容2倍，所以老桶内元素的下标应该不变or变为[老桶长度+原来的下标]，如果没有hash冲突则在原下标(此时初始化一个链表作为桶内结构)，若发生hash冲突则计算当前hash和老桶的大小，小于则还在原来的位置，大于则在新位置(源码里使用位操作 if((e.hash & oldcap)==0))
  - 8.使用两个指针记录链表的头尾节点，尾插法插入元素，处理完链表之后放入对应下标

批量插入

  - 1.如果hash桶为null，则初始化
  - 2.边界判断
  - 3.判断是否需要扩容
  - 4.循环传入的Map接口实现类的对象，调用单次插入

单次插入

  - 1.如果hash桶为null，则初始化
  - 2.判断是否需要扩容
  - 3.计算下标，如果没有hash冲突则直接插入
  - 4.如果有hash冲突并且key相同，则覆盖value
  - 5.如果没有相同key，根据节点的性质(红黑树or链表)插入，插入后判断是否需要链表升级红黑树
  - 6.判断是否需要扩容

扰动函数：hash = key.hash ^ key.hash>>16  // 右移16位，目的是为了使得hash值更均衡(key的hash值32位，这样前后16位正好混在一起了)

jdk1.8新增：

  - 1.v putIfAbsent(k key v value) 若key对应的value存在则不覆盖
  - 2.get方法可以设置默认值，如果get的key不存在value，则返回默认值而不是null
  
jdk1.7的多线程死锁问题

  - 1.线程1和线程2一起触发了扩容，当前hashmap中假设只有一个槽有节点，节点a->节点b->null
  - 2.线程1先完成了扩容，不巧的是扩容之后节点a和b依然放在了同一个hash槽里，重点，jdk1.7里hashmap的扩容用的是头插法！！！
  - 3.所以扩容后该槽内的引用是节点b->节点a->null，此时线程1的时间片恰好用完，没有能将新的node数组更新到当前hashmap对象中
  - 4.线程2开始扩容，在扩容完成之后处理节点a和b，在刚刚处理完节点a的时候，线程1又得到了时间片，此时将node数组更新至hashmap对象中，注意！！！此时对于线程2来说，节点a->节点b，而在node数组更新后实际上节点b->节点a
  - 5.此时线程2处理节点b，但是会发现节点b->节点a，根据第四步，节点a->节点b的连接其实还在！！！所以实际上节点a和节点b会相互指向对方，形成回路！！！这就是jdk1.7里的死锁问题，其实际原因就是因为jdk1.7处理链表时使用了头插法！！！

为什么红黑树和链表的互转节点数量为7：因为红黑树的查询复杂度为O(logn)，而链表的平均查询复杂度为O(n/2)，当n==8时，红黑树平均查询次数刚好比链表少一次，而n==6时，红黑树的平均查询次数比链表仅快不到1次，而考虑到红黑树和链表的互转也需要消耗性能，所以以7为中间点作为两个数据结构互转边界值。

hashmap和hashtable的区别

  - 1.线程不安全---线程安全
  - 2.默认容量16---默认容量11
  - 3.使用绕动函数---直接使用key的hash
  - 4.支持kv为null---不支持kv为null
  - 5.求模使用位操作---不使用位操作
  - 6.扩容2倍---扩容2倍+1
  - 7.Map的实现类---实现了Map接口的Dictionary类子类

HashMap为何线程不安全：

  - 1.插入时hash值相同的话节点会相互覆盖，只有最后一个线程操作的结果生效
  - 2.扩容时只有一个线程会成功，其他线程会尝试再次扩容并使用新node数组，这样会造成多次不必要的扩容

HashMap为什么是扩容2倍：因为(2^n)-1在二进制下就是n个1,n个1和任何数二进制做与运算都可以充分的保证hash冲突最小化，并不是什么2^n才可以用位运算代替取模(其实你自己算一下就知道不是2^n使用位运算也可以取模，但是很容易出现hash冲突，而hashtable设置默认值11和扩容2n+1始终保持是质数也是为了减少hash冲突)

hash冲突的原因

  - 1.加载因子过大
  - 2.hash函数设计有问题

hash冲突解决方法

  - 1.开放定址法：
  
    公式：(key.hash+Di)%(n) Di直到找到没有hash冲突为止
    
    - 线性探测:i=[1,2,3......]
    - 线性补偿:i=[和n互质的数，和n互质的数，和n互质的数......]
    - 伪随机探测再散列:Di=伪随机序列

  - 2.再hash法：使用多个不同的hash函数直到没有hash冲突为止
  - 3.建立公共溢出区：建立一个和hash函数取值范围相同的基本表，另外建立一个溢出表，一旦发生冲突就将冲突填入溢出表
  - 4.拉链法：将hash值作为数组下标，数组内维护一个数据结构，hash冲突时填入该数据结构中即可
    优点：处理冲突简单，平均查找快，长度动态申请，易删
    缺点：维护指针需要额外空间，规模小的时候加载因子较小的开放定址法效率优于拉链法


