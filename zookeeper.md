## 结构

zookeeper是一个树形结构的文件系统，每个节点称为znode，每个znode最大支持存储1mb大小

## 功能

1.统一命名管理：对多台分布式服务器进行统一命名，外部客户端访问时只需要访问相同地址，zookeeper内部采用负载均衡方法调用请求到不同服务器上

2.配置监听：例如redis等服务器的配置可以设置为znode，zookeeper监听znode实时监控redis配置的变化

3.服务器上下线监控：通过监控服务器节点状态在服务器下线时实时通知客户端

## 选举

zookeeper集群由一个leader和多个follower组成

### 第一次启动选举

1.每个节点有一票，节点会投票给自己

2.对比每个节点的myid(在zookeeper的data中可以配置)，myid大的节点可以将myid小的节点的票抢走

3.票数最多的节点当选，leader选举出来后再有新节点加入也不再选举

4.如果所有节点票数都不超过节点数量的一半，则节点进入looking状态等待新节点加入

举例：节点1,2,3,4,5的myid分别为1,2,3,4,5

初次启动时节点1,2加入集群，票数情况

```
节点1 | 节点2 |
  1  |   1   |
```

此时节点进入looking状态

根据myid分配之后

```
节点1 | 节点2 |
  0  |   2   |
```

节点3,4加入

```
节点1 | 节点2 | 节点3 | 节点4 |
  0   |  2   |   1  |   1  |
```

再次根据myid分配

```
节点1 | 节点2 | 节点3 | 节点4 |
  0   |  0   |   0  |   4  |
```

此时节点4当选，节点5加入

```
节点1 | 节点2 | 节点3 | 节点4 | 节点5 |
  0   |  0   |   0  |4 leader|   1   |
```

### 非首次选举

再zookeeper的运行过程中如果节点发生变化则可能触发再次选举

zookeeper依靠节点之间的心跳检测嗅探其他节点，如果follower嗅探leader失败则会发起新选举

zookeeper中除了myid还有任期和事务id，任期是一个leader当选后+1,如果此时没有leader，则全部节点任期一致，事务id再每次提交事务时+1，可以根据事务id的大小判断当前节点是否同步到了最新状态，比如leader的事务id=10,follower2的事务id=8,那么follower的数据并未同步到最新状态

情况1：follower发生了分区错误或自己网络阻塞，可通过其他follower同步leader状态，此时不需要重新选举

情况2：leader挂了，进行再次选举，选举规则如下

  - 任期大的优先
  - 任期相同时事务id大的优先
  - 事务id相同时myid大的优先

## 节点类型

1.无编号持久型：znode设置后客户端和服务器断开连接该节点的数据也不会被删除，不能重复创建

2.有编号持久性：znode设置后客户端和服务器断开连接该节点的数据也不会被删除，可以重复创建，每次创建后会在节点名称后加一个自增编号，改编号不会自减

3.无编号临时型：znode设置后客户端和服务器断开连接该节点的数据会被删除，不能重复创建

4.无编号临时型：znode设置后客户端和服务器断开连接该节点的数据会被删除，可以重复创建，每次创建后会在节点名称后加一个自增编号，改编号不会自减

## 监听器

zookeeper通过监听器监听znode状态，监听器默认设置一次后只能监听一次变化

1.在程序的主线程中创建zookeeper客户端，该客户端会创建两个线程，一个负责建立连接(connect)，另一个负责监听(listenser)

2.connect线程连接成功后会将客户端要监听的事件注册到zookeeper的监听列表中，该事件的数据结构为 客户端:ip:port:事件路径

3.zookeeper监听到事件发生变化会通过process方法回调给listenser，listenser将事件变化返回给客户端完成监听

