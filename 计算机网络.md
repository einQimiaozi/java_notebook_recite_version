## OSI七层模型

1.物理层：传输电信号和原始比特流(二进制数据)
  - 常见应用：网线，集线器，网卡
  - 常见协议：IEEE，InternetWork

2.数据链路层：物理寻址，透明传输，封装成帧，差错检测，该层只能建立局域网之间的数据传输
  - 常见应用：网桥，交换机
  - 常见协议：PPP，ARP，RARP

3.网络层：通过路由建立跨网关之间的链接，将mac报文封装成ip数据报
  - 常见应用：路由器
  - 常见协议：ipv4,ipv6
  - 路由协议：r2p

4.传输层：对数据进行分组，提供端到端的可靠链接
  - 常见应用：网关
  - 常见协议：tcp,upd

5.会话层：管理传输层建立的端到端之间的会话和链接，维持会话
  - 常见应用：网关
  - 常见协议：ssl，tls(安全协议)，RPC远程调用协议

6.表示层：对其上下层送来的数据进行解密，压缩，解码等，保证送到应用层的数据格式统一

7.应用层：对os和应用提供网络访问服务
  - 常见应用：网关
  - 常见协议：http，dns，ftp，dhcp，smtp，pop3

## TCP/IP四层模型

1.数据接口层：对应osi中的1,2层，提供tcp/ip协议和物理设备之间的交互接口
  - 常见协议：ARP，RARP

2.网络层：对应OSI中的网络层

3.传输层：对应OSI中的传输层

4.应用层：对应OSI的5,6,7层

## arp协议

该协处于数据链路层，向上层提供服务，由于ip数据包以以太网发送，而以太网不识别ip地址，arp协议的任务就是将ip地址转换为mac地址以保证通信，rarp则是反过来，通俗来说，就是帮助数据包能突破网关，在网关之间传递

arp解析过程：

  - 1.查询自己的arp缓存列表(该列表保存了mac地址到ip地址的映射)
  - 2.如果没有缓存则发起一个目标地址为12个f的arp广播
  - 3.主机收到广播后会检查自己的ip地址和arp请求的ip地址是否一致，如果一致则将该映射缓存到自己的arp列表中并对该arp请求做响应
  - 4.arp请求收到响应后缓存该映射，如果没有收到任何一个响应，则查询失败

## RPC

rpc本身不是一种具体的协议，而是一种过程，简单来说就是一个节点远程请求另一个节点的服务，rpc协议规定的其实就是两个节点之间编组和解组的规则

rpc可以基于不同的协议，比如http，tcp，使用序列化方式传输节点之间的数据流，不同的序列化方式会造成传输效率的差异

java中rpc协议下节点调用另一个节点的服务，本质是调用另一个节点的本地动态代理

## tcp和udp的区别

1.tcp首部20字节，udp首部8字节

2.tcp使用可靠全双工信道提供可靠传输服务，预先进行tcp三次握手，upd使用不可靠信道，目标是尽最大努力交付

3.tcp面向字节流，udp面向报文，所以tcp可能粘包

4.udp无拥塞处理机制，网络中出现阻塞时不会降低发送端的发送效率

5.tcp只支持点对点，udp支持点对点，一对多，多对多

## tcp三次握手

1.客户端和服务器创建TCB进程控制块，服务器进入监听状态等待客户端连接请求

2.客户端发出请求，seq=x(序列号)，syn置为1,tcp规定syc=1的报文不能携带数据，消耗一个序列号，一般用于建立连接和请求

3.服务器若同意连接则发出确认报文，seq=y，ack置为1且ack号=x+1

4.客户端收到服务器发来的确认报文，比较ack号，若ack号正确，则发送ack号=y+1并将序列号seq=x+1返回给服务器，若服务器确认ack号正确，则客户端服务器进入已建立链接状态，之后就可以开始通信了

## 为什么要三次握手

1.如果是两次握手，对于客户端的数据包，可通过seq进行确认

2.但服务器返回客户端的数据包无法通过seq进行确认，因为没有客户端返回的确认信息了

3.三次握手本质上合并了四次握手中的第二次和第三次

4.所以理由如下：
  - 保证双方传输的可靠性
  - 提高传输效率

## 四次挥手

1.客户端发送释放链接报文，fin=1,seq=x,之后进入等待状态1

2.服务器发送确认报文，ack置为1并ack号=x+1,seq=y,进入从close-wait状态，并通知应用进入半管理状态

3.客户端收到确认报文，核对ack，之后进入停止等待状态2

4.服务器将剩余数据发送完毕，假定seq此时为y+n,同时向客户端发送fin=1,seq=y+n，之后进入最后确认状态

5.客户端收到释放链接报文后，确认ack=y+n+1,seq=x+1,进入时间等待状态，等待两个最大报文寿命(2MSL)后关闭链接，销毁对应的tcb块，进入closed状态

6.服务器收到客户端确认报文，关闭链接，销毁tcb，进入closed状态

## 为什么要四次挥手

1.因为tcp是全双工通道

2.对于两台主机，每次收到的fin报文只保证发送方不会再发来数据，但不保证自己再次发送数据，即只关闭了单向通道

3.所以需要四次握手关闭双向通道，本质上其实是两个两次握手

## 为什么要等2MSL

因为最后一次挥手时如果丢包，则服务器会重新进行第三次挥手，此时如果客户端擅自断开了和服务器的链接，无法响应服务器的第三次挥手，服务器会处于无法断开链接的状态，造成网络延迟

## 为什么序列号不能从0开始，为什么序列号是随机开始的

1.防止tcp报文伪造

2.如果都从0开始，那么不同数据包只要长度一样，seq和ack就一样了，可能会产生粘包，导致不属于同一个完整数据包的两段数据包被错判为同一个数据包

## tcp的数据传输控制机制

1.超时重传：使用RTO重传定时器，根据多次往返时间(RTT)的平均值确定RTO，如果出现超时(即未收到ack)，则认为报文丢失，重传(linux15次，windows5次)

2.流量控制：使用tcp滑动窗口规定每次传输的数据范围，只有收到确认ack后才移动窗口，并且接收端可以根据自己的情况设置窗口大小，从而进行流量控制

3.拥塞控制：
  - 1.慢开始：通过提前嗅探网络拥塞状况控制发送的数据量，从小到达依次慢慢增加拥塞窗口(拥塞窗口可以理解为滑动窗口)，每次增加双倍，初始大小为1
  - 2.拥塞避免：执行慢开始出现拥塞时，将拥塞阈值变为一半，并将拥塞窗口置为1,之后每次增加拥塞窗口+1而不是两倍
  - 3.快重传：发送方连续收到三个相同的ack确认后，则认为接收方出现了丢包(接收方发现丢包的话就向发送方连续发三个ack确认)，则停下其他报文的发送，优先将丢失的数据包重传后，再次恢复其他数据包的发送
  - 4.快恢复：发送方连续收到n(n>=3)个相同的ack确认后，将拥塞阈值减半，将拥塞窗口置为阈值+n,直到收到了新的ack后，再将拥塞窗口重置为阈值大小

## http(超文本传输协议)

概念：基于b/s或c/s的tcp/ip通信协议，是为了实现某一类具体应用的协议

1.常见状态码
  - 1xx：接收的请求正在被处理
  - 2xx：请求成功处理完毕
  - 3xx：请求需要客户端后续附加其他操作
  - 4xx：服务器无法处理请求
  - 5xx：服务器出错

2.http1.0：
  - 默认短连接(可以设置为长连接，参数keey-alive)
  - 连接无法复用，每次都要重新tcp三次握手
  - 请求会阻塞

3.http1.1：
  - 默认长连接
  - 支持只发送header信息
  - 支持host域请求
  - 支持断点续传，身份验证，状态管理等功能

4.http2.0：
  - 支持多路复用模型，允许单一连接发起多重请求-响应消息，但对同一域名下有数量限制
  - 通信基本单位为帧，在应用层和传输层之间增加了分帧层
  - 支持首部压缩算法
  - 支持服务器推送(一条请求可以获得多条响应)

5.https：
  - 加密版http，使用ca证书，收费
  - 使用ssl+http协议构建加密传输
  - 连接端口为433,http为80

6.ssl：
  - 通过数字签名方法进行身份验证
  - 通过对称密钥算法对传输数据加密
  - 使用mac算法验证消息完整性

## GET和POST

1.浏览器回退时：get无害，post可能会重新提交数据

2.get能被缓存，post不能

3.get的参数保留在浏览器历史记录上，post不会

4.get只接受ascii格式参数，post无限制(甚至可以用二进制)

5.不同浏览器针对get请求长度可能有限制，post任何时候都无长度限制

6.post的参数不在url中，会更安全

## url从输入浏览器到返回前端界面的全过程

1.判断输入是url还是字符串(有些浏览器自带搜索引擎)，并将url中的unicode字符转换为ascii

2.检查hsts表(注册在该表的网站要求使用https进行加密安全链接)，决定使用http还是https(如果网站要求https但没有在hsts中注册则第一次连接使用http，之后使用https)

3.dns查询：查询本地host文件和浏览器缓存 -> 查询arp缓存和本地路由列表中子网的缓存 -> 若本地dns服务器没找到结果 -> 从根域名服务器迭代+递归查找ip地址

4.先对目标地址进行tcp三次握手建立链接

5.建立链接后如果是https，则服务器会告知浏览器自己的tls版本并发送公钥和证书给客户端，客户端使用加密的随机数发送给服务器，服务器解密后生成对称密钥，接下来的会话全部使用该密钥加密进行

6.服务器使用httpd(超文本传输协议主程序，常见的如nginx)接收客户端请求并拆分出请求方法，域名，请求资源路径等参数

7.get请求直接返回相应内容，如果请求的是动态资源，则将该资源文件解析(比如google使用php解析)

8.根据文件内容读取对应资源，这里会前置一个ormmapping，用于对查询的资源进行缓存，缓存不命中才进入数据库查询，减少数据库压力

9.如果需要进入数据库查询，ormapping会解析查询，将其转成sql语句之类的数据库查询语句送入后端数据库执行

10.将返回的结果通过ormapping转成模型对象，进行逻辑处理后送到视图层渲染，通过动态脚本解析器送回http服务器，http服务器对其封装响应头后通过tcp协议发回给浏览器

11.浏览器判断响应码，根据响应码和收到的数据构建dom树，之后根据css样式和dom树构建渲染树，显示在浏览器中

## dns查询过程

1.检查本地host文件是否有这个网址的映射

2.检查本地dns缓存

3.检查tcp/ip设置中的首选dns服务器的本地配置资源

4.若以上都没查到，并且本地dns服务器设置了转发，则将请求转发给上级dns服务器，直到解析成功

5.若没有设置转发，则将请求转发给根域名服务器，由其判断该域名是谁管理，并将管理者域名返回，本地dns服务器联系该管理者，如果解析失败，则向该管理者的下级继续查询，直到解析成功

## cookie和session

1.cookie是一小段的文本信息,由服务器向客户端发送一个cookie用于记录该客户端的身份，主要是为了解决http这种无状态协议下识别访问者身份的问题

2.session将cookie“缩小成一个id”，这样cookie就不需要大量存放在客户端了，也不需要每次在服务器和客户端之间传输，减少网络延迟和发送量，服务器使用id检索cookie(session的cookie存在服务器上)验证身份

3.区别：
  - session可以存任意java对象，cookie只能存string
  - session存在服务器上，cookie存在客户端上
  - cookie存在本地，不安全，session存在服务器，更加安全不易篡改
  - 单个cookie上限4k大小，一个站点在浏览器上只能保存最多20个cookie
  - session虽然无限制，但是要消耗服务器资源，所以一般只存重要数据
  - session无法跨域(同一父域名的子域名也不行)，cookie可以，session的解决方案是使用cookie保存session的id，实现跨域资源共享
