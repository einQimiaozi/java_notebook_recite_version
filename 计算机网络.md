## OSI七层模型

1.物理层：传输电信号和原始比特流(二进制数据)
  - 常见应用：网线，集线器，网卡
  - 常见协议：IEEE，InternetWork

2.数据链路层：将物理层的数据封装成mac数据报，主要功能有物理寻址，透明传输，封装成帧，差错检测，该层只能建立局域网之间的数据传输
  - 常见应用：网桥，交换机
  - 常见协议：PPP，ARP，RARP

3.网络层：通过路由建立跨网关之间的链接，将mac报文封装成ip数据报，提供点对点服务，也就是主机之间的通信
  - 常见应用：路由器
  - 常见协议：ipv4,ipv6
  - 路由协议：r2p

4.传输层：对数据进行分组，提供端到端的可靠链接，也就是进程间的通信
  - 常见应用：网关
  - 常见协议：tcp,upd
  - tcp加上特定端口号就可以提供某个应用层协议，比如:tcp+80=http tcp+443=https

5.会话层：管理传输层建立的端到端之间的会话和链接，维持会话
  - 常见应用：网关
  - 常见协议：ssl，tls(安全协议)，RPC远程调用协议

6.表示层：对其上下层送来的数据进行解密，压缩，解码等，保证送到应用层的数据格式统一

7.应用层：对os和应用提供网络访问服务
  - 常见应用：网关
  - 常见协议：http，dns，ftp，dhcp，smtp，pop3

## TCP/IP四层模型

1.数据接口层：对应osi中的1,2层，提供tcp/ip协议和物理设备之间的交互接口
  - 常见协议：ARP，RARP

2.网络层：对应OSI中的网络层

3.传输层：对应OSI中的传输层

4.应用层：对应OSI的5,6,7层

## arp协议

该协处于数据链路层，向上层提供服务，由于ip数据包以以太网发送，而以太网不识别ip地址，arp协议的任务就是将ip地址转换为mac地址以保证通信，rarp则是反过来，通俗来说，就是帮助数据包能突破网关，在网关之间传递

arp解析过程：

  - 1.查询自己的arp缓存列表(该列表保存了mac地址到ip地址的映射)
  - 2.如果没有缓存则发起一个目标地址为12个f的arp广播
  - 3.主机收到广播后会检查自己的ip地址和arp请求的ip地址是否一致，如果一致则将该映射缓存到自己的arp列表中并对该arp请求做响应
  - 4.arp请求收到响应后缓存该映射，如果没有收到任何一个响应，则查询失败

## RPC

RPC协议规定允许互联网中一台主机程序调用另一台主机程序，而程序员无需对这个交互过程进行编程。在RPC协议中强调当A程序调用B程序中功能或方法时，A是不知道B中方法具体实现的。

RPC是上层协议，底层可以基于TCP协议，也可以基于HTTP协议。一般我们说RPC都是基于RPC的具体实现，如：Dubbo框架。从广义上讲只要是满足网络中进行通讯调用都统称为RPC，甚至HTTP协议都可以说是RPC的具体实现，但是具体分析看来RPC协议要比HTTP协议更加高效，基于RPC的框架功能更多。

对比http:
  - 可以基于http，也可以基于tcp
  - 报文体积较小(http2.0后rpc和http报文体积差不多大)
  - 支持长连接
  - 序列化方式不仅限于json，比如thrift等
  - 自带负载均衡，服务治理等功能

序列化:将对象状态转换为可保持或传输的二进制

反序列化:将二进制数据转换为对象的过程

## dhcp协议

dhcp协议用于给内网主机动态分配ip地址，底层使用udp实现，67端口用于发送dhcp请求，68端口用于响应请求发送dhcp offer

工作流程
  - 主机首先通过67端口发送DHCP Discover广播
  - dhcp服务器收到广播后查询自己的配置文件中未分配的最靠前的ip地址，通过68端口发送DHCP offer给主机分配该地址
  - 主机收到多个dhcp服务器的offer后选择最先到达的那个并以广播的方式回答一个DHCP request数据包，指明接收哪个offer，未被接受的dhcp服务器撤销offer
  - DHCP服务器接收到客户机的DHCP request之后，会广播返回给客户机一个DHCP ack消息包，表明已经接受客户机的选择，告诉DHCP客户端可以使用它提供的IP地址

## icmp协议

icmp协议基于ip协议，用于检测网络通信状况

icmp协议分两种，差错报文和查询报文

差错报文：

![a](https://img-blog.csdnimg.cn/20190315150246911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjMxNDEz,size_16,color_FFFFFF,t_70)

![a1](https://img-blog.csdnimg.cn/20190315151847350.png)

查询报文

![b](https://img-blog.csdnimg.cn/20190315155432238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjMxNDEz,size_16,color_FFFFFF,t_70)

类型字段指出了是请求报文（8）还是回答报文（0）

常用的查询报文有两种
  - 回送请求或回答
  - 时间戳请求或回答

主要在主机启动时使用，通过使用这两种查询报文，主机能确定自身在网络环境中IP地址、地址掩码、路由器状况等信息

## IP

ip地址 = 网络地址+主机地址

判断两台主机是否能够在局域网内通信(是否在同一网段)

ip地址的二进制和该网关子网掩码的二进制做与(AND)运算，如果两个主机的运算结果一致，那么他们处于同一网段

将子网掩码取反后和ip地址做与运算，得到的结果就是该主机的主机标识号

## tcp/udp

1.tcp：TCP协议是基于IP协议的，一个TCP连接中的IP首部中的发送端IP地址加上发送端端口号就形成了连接的发送端；目标端IP地址再加上接收端端口号
就确定了连接的接收端。这样就唯一地确定了一个TCP连接，tcp是面向字节流的协议

2.udp：UDP是面向报文的，应用层交下来的报文，不合并也不拆分，添加UDP首部后就直接向下交付给IP层，也就是一次发送一个报文；UDP在传送数据之前不需要建立连接，收到后也不需要给出确认，所以没有办法保证可靠交付。

![tcp首部](https://note.youdao.com/yws/public/resource/513a48530d4ce8dd5e60309ba463a0e7/xmlnote/2ACF7321B65F488FB575A2B65581793D/12811)

3.tcp首部：
  - 源端口和目的端口：各占两个字节；(16bit的端口号+32bit的ip地址形成了一个套接字socket，每一条TCP连接唯一的被两端的两个端点也就是两个套接字确认，所以这也构成了传输层的点到点通信)
  - 序号(seq)：占4个字节；(在传输的数据中，每一个字节都有一个序号，这个序号就是本次传输数据的第一个字节的序号)；
  - 确认号(ack)：占4个字节；(这个值是代表期待收到对方下次发送的数据的第一个字节的序号，比如如果发送ack=301，则表示前300个我收到了，下次你给我发第301个)；
  - 数据偏移：占4位，也叫首部长度(Header length),一般情况下首部长度是20字节，但是也可以扩展，比如这4位都置为1时十进制是15，代表可以首部可以有15行，一行4个字节，所以是60个字节；
  - URG:紧急指针有效位，和第5行的紧急指针一起用，可以让紧急数据进行加塞，接收端可以优先快速的获取紧急数据；
  - ACK:指示ack确认号是否有效；
  - PSH:置为1时表示将本报文段立即向上交付有应用层，而不用等缓存填满再交付；
  - RST:置为1时通知重新建立TCP连接；
  - SYN:同步序号位，置为1表示需要建立连接；比如SYN=1,ACK=0时表明是一个连接建立请求；而SYN=1,ACK=1,表明是一个连接接受请求；  
  - FIN:置为1时表明发送数据结束，连接释放；
  - 窗口：占2个字节：用来说明本地可以接收的数据段的数目，以字节为单位，流量控制就是基于这个窗口来实现的，其大小是可变的；
  - 检验和：占2个字节：用来做差错控制，在发送端计算一次所有数据的检验和，在接收端再计算一次，一致则说明数据基本正确；
  - 紧急窗口：和URG配合使用；

## tcp和udp的区别

1.tcp首部20字节，udp首部8字节

2.tcp使用可靠全双工信道提供可靠传输服务，预先进行tcp三次握手，upd使用不可靠信道，目标是尽最大努力交付

3.tcp面向字节流，udp面向报文，所以tcp可能粘包

4.udp无拥塞处理机制，网络中出现阻塞时不会降低发送端的发送效率

5.tcp只支持点对点，udp支持点对点，一对多，多对多

## tcp三次握手

1.客户端和服务器创建TCB进程控制块，服务器进入监听状态等待客户端连接请求

2.客户端发出请求，seq=x(序列号)，syn置为1,tcp规定syc=1的报文不能携带数据，消耗一个序列号，一般用于建立连接和请求

3.服务器若同意连接则发出确认报文，seq=y，ack置为1且ack号=x+1

4.客户端收到服务器发来的确认报文，比较ack号，若ack号正确，则发送ack号=y+1并将序列号seq=x+1返回给服务器，若服务器确认ack号正确，则客户端服务器进入已建立链接状态，之后就可以开始通信了

## 为什么要三次握手

1.如果是两次握手，对于客户端的数据包，可通过seq进行确认

2.但服务器返回客户端的数据包无法通过seq进行确认，因为没有客户端返回的确认信息了

3.三次握手本质上合并了四次握手中的第二次和第三次

4.所以理由如下：
  - 保证双方传输的可靠性
  - 提高传输效率

总结：本质上是为了在不可靠的信道建立可靠的连接，防止已经失效的报文突然又到了服务器

## 四次挥手

1.客户端发送释放链接报文，fin=1,seq=x,之后进入等待状态1

2.服务器发送确认报文，ack置为1并ack号=x+1,seq=y,进入从close-wait状态，并通知应用进入半管理状态

3.客户端收到确认报文，核对ack，之后进入停止等待状态2

4.服务器将剩余数据发送完毕，假定seq此时为y+n,同时向客户端发送fin=1,seq=y+n，之后进入最后确认状态

5.客户端收到释放链接报文后，确认ack=y+n+1,seq=x+1,进入时间等待状态，等待两个最大报文寿命(2MSL)后关闭链接，销毁对应的tcb块，进入closed状态

6.服务器收到客户端确认报文，关闭链接，销毁tcb，进入closed状态

## 为什么要四次挥手

1.因为tcp是全双工通道

2.对于两台主机，每次收到的fin报文只保证发送方不会再发来数据，但不保证自己再次发送数据，即只关闭了单向通道

3.所以需要四次握手关闭双向通道，本质上其实是两个两次握手

4.在关闭连接时，服务器可能还有剩余数据没有发送完毕，所以客户端不能直接关闭连接，服务器只需要告诉客户端我收到你的关闭请求即可，不能立刻关闭，需要把剩余数据发送完毕再主动通知客户端关闭连接，即多加一次挥手

## 为什么要等2MSL

因为最后一次挥手时如果丢包，则服务器会重新进行第三次挥手，此时如果客户端擅自断开了和服务器的链接，无法响应服务器的第三次挥手，服务器会处于无法断开链接的状态，造成网络延迟

## 为什么序列号不能从0开始，为什么序列号是随机开始的

1.防止tcp报文伪造

2.如果都从0开始，那么不同数据包只要长度一样，seq和ack就一样了，可能会产生粘包，导致不属于同一个完整数据包的两段数据包被错判为同一个数据包

## tcp的数据传输控制机制

1.滑动窗口：滑动窗口的引入可以避免每次传输数据都必须有一个ack应答(这样会造成吞吐量过低)，允许接受端根据自己的接收能力设定窗口大小，窗口中的数据不需要每次ack应答确认，可以直接发送，窗口的起始位置根据ack确认号确定，窗口的结束位置即ack确认号+窗口大小，随着ack确认号的增大，窗口可以向后滑动，所以叫滑动窗口，但是引入滑动窗口会带来丢包问题

2.超时重传：当发生丢包时，接收方会将丢掉的数据段的ack号重发三次，发送端则会暂停当前数据包的发送，将丢失段重新发送

3.流量控制：tcp协议中双方都有一个缓冲区用于接收数据，在使用滑动窗口机制时，接收端的缓冲区可能会满或者缓冲区无法及时处理发送端发来的数据，接收端可根据自己缓冲区的大小调整窗口大小，而当缓冲区已满时，发送端不能再发送数据，此时发送端会向接收端定期发送窗口嗅探(定期是为了防止窗口嗅探丢包)，根据窗口大小实时调整发送数据量，实际上流量控制就是使用滑动窗口实现的端到段动态发送速度控制方法

4.拥塞控制：

重要概念：
- 拥塞窗口：跟滑动窗口一样，决定发送数据量，实际的发送窗口大小取拥塞窗口和滑动窗口中较小的那个
- 门限：拥塞窗口的阈值
- 1.慢开始：将拥塞窗口大小设置为1,每次增加一倍大小
- 2.拥塞避免：当拥塞窗口大小到达门限时，每次不再加被，而是线性增长(+1),若出现网络拥塞，则将拥塞窗口重置为1,门限减少到当前的一半，重新执行慢开始
- 3.快重传：发送方连续收到三个相同的ack确认后，则认为接收方出现了丢包(接收方发现丢包的话就向发送方连续发三个ack确认)，则停下其他报文的发送，优先将丢失的数据包重传后，再次恢复其他数据包的发送
- 4.快恢复：发送方连续收到n(n>=3)个相同的ack确认后，将门限减少到当前的一半，之后直接执行拥塞避免，拥塞窗口置为门限大小而不置为1

为什么快重传是三次：实际上就是根据工程经验得出的结论，网上有文章解释过，如果一次发送四组数据，那么3个相同ack在延迟情况下出现的概率是40%，但是在丢包情况下出现的概率时100%，不过这不能解释为什么一定是三次，因为这个例子的假设是建立在一次发送四组数据的情况下

## dns

dns是ip地址到url映射的协议的查询缓存，底层可以通过tcp或upd实现(一般为udp)，端口号为53

dns的层级

  - 根域名服务器
  - 顶级域名服务器
  - 权限域名服务器

dns查询时从上层向下查询

本地域名服务器
  - 本地域名服务器不在dns层级中，是电脑解析时的默认域名服务器，即电脑中设置的首选 DNS 服务器和备选 DNS 服务器
  - 本地域名服务器管理本地域名的解析和映射，并且能够向上级域名服务器进行查询

递归查询和迭代查询：dns查询分为这两种方式

  - 递归查询就是所有查询由发送给根域名服务器，从根向下查询
  - 迭代查询就是每次查询会先发给根域名服务器，根域名服务器只查询自己层级管理的服务器，查询失败后客户端再次发送给顶级域名服务器......


## http(超文本传输协议)

概念：基于b/s或c/s的tcp/ip通信协议，是为了实现某一类具体应用的协议

1.常见状态码
  - 1xx：接收的请求正在被处理
  - 2xx：请求成功处理完毕
  - 3xx：请求需要客户端后续附加其他操作
  - 4xx：服务器无法处理请求
  - 5xx：服务器出错

具体状态码
   - 400：报文有误无法处理
   - 403：不允许请求该资源
   - 404：请求资源不存在
   - 500：服务器故障
   - 503：服务器正在维护，稍后才能处理
   - 200：请求处理成功返回
   - 204：请求处理成功但是没有可返回数据
   - 301：永久重定向
   - 302：临时重定向

2.http1.0：
  - 默认短连接(可以设置为长连接，参数keey-alive)
  - 连接无法复用，每次都要重新tcp三次握手
  - 请求会阻塞

3.http1.1：
  - 默认长连接
  - 支持只发送header信息
  - 支持host域请求
  - 支持断点续传，身份验证，状态管理等功能

4.http2.0：
  - 支持多路复用模型，允许单一连接发起多重请求-响应消息，但对同一域名下有数量限制
  - 通信基本单位为帧，在应用层和传输层之间增加了分帧层
  - 支持首部压缩算法
  - 支持服务器推送(一条请求可以获得多条响应)

5.https：
  - 加密版http，使用ca证书，收费
  - 使用ssl+http协议构建加密传输
  - 连接端口为433,http为80

6.ssl：
  - 通过数字签名方法进行身份验证
  - 通过对称密钥算法对传输数据加密
  - 使用mac算法验证消息完整性

7.ssl的具体流程
  - 1.服务器向ca机构申请ca证书并上交自己的公钥，秘钥不交
  - 2.ca机构对申请者进行核实
  - 3.ca机构向申请者下发ca证书，证书主要包括申请者公钥，申请者信息，发证机构信息，签名，有效期等
  - 4.客户端访问服务器时会接收服务器利用公钥加密发来的数字证书，客户端利用ca机构在浏览器中存放的公钥对证书进行验证，这一步强调客户端对ca机构的完全信任
  - 5.验证成功后客户端用服务器发来的证书中的公钥对自己随机生成的一段数字进行加密，发送给服务器
  - 6.服务器利用自己的私钥进行解密，接下来服务器和客户端的通信都使用解密后的这串数字作为密钥加密通信
  - ps：上面说的这个流程也叫非对称加密算法，即客户端和服务器加密时使用的钥匙不是同一把，如果双方都使用公钥加密解密，则称为对称加密算法

## GET和POST

get和post是两种基本的http请求方法，get主要用于获取数据，post主要用于修改数据

1.浏览器回退时：get无害，post可能会重新提交数据

2.get能被缓存，post不能

3.get的参数保留在浏览器历史记录上，post不会

4.get只接受ascii格式参数，post无限制(甚至可以用二进制)

5.不同浏览器针对get请求长度可能有限制，post任何时候都无长度限制

6.post的参数不在url中，会更安全

## url从输入浏览器到返回前端界面的全过程

1.判断输入是url还是字符串(有些浏览器自带搜索引擎)，并将url中的unicode字符转换为ascii

2.检查hsts表(注册在该表的网站要求使用https进行加密安全链接)，决定使用http还是https(如果网站要求https但没有在hsts中注册则第一次连接使用http，之后使用https)

3.dns查询：查询本地host文件和浏览器缓存 -> 查询arp缓存和本地路由列表中子网的缓存 -> 若本地dns服务器没找到结果 -> 从根域名服务器迭代+递归查找ip地址

4.先对目标地址进行tcp三次握手建立链接

5.建立链接后如果是https，则服务器会告知浏览器自己的tls版本并发送公钥和证书给客户端，客户端使用加密的随机数发送给服务器，服务器解密后生成对称密钥，接下来的会话全部使用该密钥加密进行

6.服务器使用httpd(超文本传输协议主程序，常见的如nginx)接收客户端请求并拆分出请求方法，域名，请求资源路径等参数

7.get请求直接返回相应内容，如果请求的是动态资源，则将该资源文件解析(比如google使用php解析)

8.根据文件内容读取对应资源，这里会前置一个ormmapping，用于对查询的资源进行缓存，缓存不命中才进入数据库查询，减少数据库压力

9.如果需要进入数据库查询，ormapping会解析查询，将其转成sql语句之类的数据库查询语句送入后端数据库执行

10.将返回的结果通过ormapping转成模型对象，进行逻辑处理后送到视图层渲染，通过动态脚本解析器送回http服务器，http服务器对其封装响应头后通过tcp协议发回给浏览器

11.浏览器判断响应码，根据响应码和收到的数据构建dom树，之后根据css样式和dom树构建渲染树，显示在浏览器中

## dns查询过程

1.检查本地host文件是否有这个网址的映射

2.检查本地dns缓存

3.检查tcp/ip设置中的首选dns服务器的本地配置资源

4.若以上都没查到，并且本地dns服务器设置了转发，则将请求转发给上级dns服务器，直到解析成功

5.若没有设置转发，则将请求转发给根域名服务器，由其判断该域名是谁管理，并将管理者域名返回，本地dns服务器联系该管理者，如果解析失败，则向该管理者的下级继续查询，直到解析成功

## cookie和session

cookie和session都是用来跟踪浏览器用户身份的会话方式

1.cookie是一小段的文本信息（键值对）,由服务器创建并向客户端发送一个cookie用于记录该客户端的身份，主要是为了解决http这种无状态协议下识别访问者身份的问题，cookie保存在浏览器中

2.服务器在创建session的时候会同时创建一个cookie用于标识sessionid(key为固定的jsession，value为sessionid)，之后再访问时服务器根据客户端的这个特殊cookie查找其session，即session时存在服务器上而不是客户端上

3.区别：
  - session可以存任意java对象，cookie只能存string
  - session存在服务器上，cookie存在客户端上
  - cookie存在本地，不安全，session存在服务器，更加安全不易篡改
  - 单个cookie上限4k大小，一个站点在浏览器上只能保存最多20个cookie
  - session虽然无限制，但是要消耗服务器资源，所以一般只存重要数据
  - session的实现一般依赖sessionid，但是sessionid需要用cookie实现，如果浏览器禁用cookie，那么session也会失效，不过可以通过在url中传递sessionid解决

4.总结：sessionid时维持会话的客户端唯一标识
